%\VignetteIndexEntry{biomaRt}
%\VignetteDepends{biomaRt}
%\VignetteKeywords{biomaRt}
%\VignettePackage{biomaRt}
%\documentclass[12pt, a4paper]{article}
\documentclass[12pt]{article}

\usepackage{amsmath,epsfig,psfig,pstricks,fullpage}
\usepackage{hyperref}
\usepackage{url}
\usepackage[authoryear,round]{natbib}

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}




\author{Steffen Durinck$^\ddagger$\footnote{Steffen.Durinck@esat.kuleuven.ac.be}, Wolfgang Huber$^\P$\footnote{huber@ebi.ac.uk},\\Yves Moreau$^\ddagger$, Bart De Moor$^\ddagger$}
\begin{document}
\title{Description of the biomaRt package}

\maketitle
\begin{center} $^\ddagger$Department of Electronical Engineering, ESAT-SCD, K.U.Leuven,\\ Kasteelpark Arenberg 10, 3001 Leuven-Heverlee, Belgium, \url{http://www.esat.kuleuven.ac.be/~dna/BioI}\\and $^\P$European Bioinformatics Institute, Hinxton, UK

 \end{center}

%library(tools)
%Rnwfile<- file.path("/home/steffen/programming/R/biomaRt/inst/doc/biomaRt.Rnw")
%Sweave(Rnwfile,pdf=TRUE,eps=TRUE,stylepath=TRUE,driver=RweaveLatex())

\tableofcontents
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
The BioConductor \Rpackage{biomaRt} package provides and API in R to query BioMart databases such as Ensembl (http://www.ensembl.org), a software system which produces and maintains automatic annotation on metazoan genomes.  Two sets of functions are currently implemented.\\  
A first set of functions is tailored towards Ensembl and are a set of commonly used queries in microarray data analysis.
A second set of functions aims to mimic functionality of other BioMart API's such as Martshell, Martview, etc. (see http://www.biomart.org for more information).  These functions are very general, and can be used with any BioMart system.  They allow retrieval of all information that other BioMart API's provide. With these two sets of functions, one can for example annotate the features on your array with the latest annotations starting from identifiers such as affy id's, locuslink, RefSeq, entrezgene,.. Annotation includes gene names, GO, OMIM annotation, etc.  On top of this, biomaRt enables you to retrieve any type of information available from the BioMart databases from R.\\

\section{objects}

\subsection{Mart-class}

An object of the \Robject{Mart} class stores connections to BioMart databases and aditional information about the BioMarts. It has the following slots:
\begin{itemize}
\item \Robject{connections}: stores the RMySQLConnections
\item \Robject{arrayToSpecies}: Stores mapping from affy arrays to species
\end{itemize}


\section{Simple biomaRt functions for frequently used queries to Ensembl}
In this section we describe a set of simple functions which are frequently used in the microarray community.  More powerful functions and data retrieval from all BioMart databases is described in the next section "Advanced data retrieval with BioMart API functions".

\subsection{Connecting to BioMart databases}

A first step in using the biomaRt package is to connect to a BioMart database. The function martConnect establishes a connection with one or more of the following BioMart databases: snp, ensembl, sequence and vega.  Default this function will connect to public BioMart databases.  If no biomart is specified, only a connection to ensembl will be established.  If you want to use local BioMart install you have to set the local argument to TRUE and specify host, password and user details in the corresponding arguments.   

\subsubsection{\Rfunction{martConnect}}

<<>>=
library(biomaRt)
#Connect to BioMart databases, using default (ensembl)
mart <- martConnect()
 
@

\subsubsection{\Rfunction{martDisconnect}}

You can only hold a limited number of connections with different BioMarts.  The function martDisconnect can be used to close a mart connection.

<<>>=

#Disconnect from BioMart databases

martDisconnect(mart)
 
@

\subsection{Annotating identifiers with gene information}

The function \Rfunction{getGene} uses a query id to look up the name, description and chromosomal information of the corresponding gene.
Currently the \Rfunction{getGene} function takes identifiers from entrezgene, ensembl, refseq, affy, hugo and embl.  Besides the id argument, this function also has a species, array and type argument.\\
The {\it id} argument is either a vector of identifiers or a single identifier to be annotated.\\
 The {\it species} argument should have the species from which the identifier originates.\\
The {\it array} argument takes affy array identifiers as values.  A list of possible identifiers supported by the package can be obtained by executing the function \Rfunction{getAffyArrays}.\\
The {\it mart} argument is a mart connection, which was obtained using the method \Rfunction{martConnect}.\\
The {\it type} takes the values of 'entrezgene','refseq','hugo', 'ensembl' and 'embl' to clarify which type of identifier is specified in the id argument.\\

First we connect to the BioMart databases we need (note that this should happen only once per session).  

<<>>=

mart <- martConnect(biomarts = c("ensembl", "snp","sequence")) 

@

Then we check which affy arrays are available:

<<>>=


getAffyArrays(mart)

@

Assume now that we have some upregulated features that we want to annotate. To get the gene information on a certain affy array do:

<<>>=

upregulated <- c("210708_x_at","202763_at","211464_x_at")

gene <- getGene( id = upregulated, array = "hgu133plus2", mart = mart)

gene
@

When using other id's we have to specify the \texttt{type} and \texttt{species}, use the function \Rfunction{getSpecies} to find valid species names.

<<>>=
getGene(id=100,species="hsapiens",type="entrezgene",mart=mart)

@


\subsubsection{GO annotation}

Gene Onotology annotation can be retrieved with the function \Rfunction{getGO}.  The arguments are the same as the function \Rfunction{getGene}.

<<>>=
go <- getGO( id = upregulated[1], array = "hgu133plus2", mart = mart)
go
@

\subsubsection{OMIM annotation}

OMIM annotation can be retrieved with the function \Rfunction{getOMIM}.  The arguments are the same as the function \Rfunction{getGene}.

<<>>=
omim <- getOMIM( id = "203140_at" , array = "hgu133plus2", mart = mart)
omim
@

\subsubsection{INTERPRO protein domains}

INTERPRO protein domains of the corresponding proteins can be searched with the function \Rfunction{getINTERPRO}. Again the arguments are the same as the function \Rfunction{getGene}.  

<<>>=

getINTERPRO(id="1939_at",array="hgu95av2",mart=mart)

@


\subsection{Homology mapping}

This function maps homologs of genes of one species to another species.
To see which species are available do:\\

<<>>=
getSpecies(mart)

@

Now we can look for homologs:

<<>>=

getHomolog(id = 2,from.species = 'hsapiens', to.species = 'mmusculus', from.type = 'entrezgene', to.type = 'refseq',mart = mart)

getHomolog(id = "1939_at",to.array = "canine", from.array = "hgu95av2",mart = mart )

@


\subsection{Identify subsets of genes for further analysis with the \Rfunction{getFeature} function}

The function \Rfunction{getFeature} is a general function to look up identifiers which pass a certain filter.  A first such a filter is to look for identifiers that correspond to genes with a given symbol.  If the array argument is given then affy identifiers from that array will be returned.  For retrieving other identifiers one has to specify the species and the type of identifier to retrieve.\\

<<>>=
getFeature(symbol="BRCA2",array="hgu95av2",mart=mart)
@

A second possible filter is to look for id's which have a certain OMIM disease term attached to them (this only works for hsapiens).

<<>>=
getFeature(OMIM="diabetes mellitus", type="refseq", species="hsapiens",mart=mart)
@

Similarly one can look for id's that have a certain GO annotation e.g. retrieve all affy id's on the hgu133plus2 array which have protein-tyrosine kinase activity.\\

<<>>=

tyrkinase <- getFeature(GO="protein-tyrosine kinase",array="hgu133plus2",mart=mart)

@

An other filter uses the position of genes on the genome.  One can query for all genes on a certain chromosome:

<<>>=
ychrom <- getFeature(chromosome="Y",type="entrezgene",species="hsapiens",mart=mart)
ychrom@id[1:10]

@

Or query for genes that lay in a particular region:\\

<<>>=
getFeature(chromosome=21,start=30000000, end = 35000000, array="hgu95av2",mart=mart)
@

\subsection{Sequence information}

The function \Rfunction{getSequence} retrieves the sequence given it's chromosome, start and end position.

<<>>=

getSequence(species="ggallus", chromosome = 1, start = 400, end = 500, mart = mart)

@


\subsection{Single Nucleotide Polymorphisms}

The function \Rfunction{getSNP} retrieves all SNP's between a given a start and end position on a gives chromosome..
Note:  make sure you have a Mart object with connections to ensembl and snp

<<>>=

getSNP(chromosome = 8, start = 148350, end = 148612, species ="hsapiens", mart = mart)

@

\subsection{More exotic functions}
\subsubsection{\Rfunction{getPossibleXrefs}}

This function retrieves the possible cross-references present in Ensembl.  This is a very general function to see what can be extracted from En
sembl.  The results of this function can be used in the getXref function to extract the data of interest.

<<>>=
xref <- getPossibleXrefs(mart = mart)
xref[1:10,]

@


\subsubsection{\Rfunction{getXref}}

This powerful function retrieves any cross reference in Ensembl.  It can for example be used to map different affymetrix array within one species.
E.g. starting from an affy id of chip hgu95av2 and id 1939\_at, look for corresponding affy identifiers on the affy hgu133plus2 chip.

<<>>=

getXref(id=c("1939_at"), from.species="hsapiens", to.species = "hsapiens", from.xref ="affy_hg_u95av2", to.xref="affy_hg_u133_plus_2",mart=mart)
martDisconnect(mart)

@


\section{Advanced data retrieval with BioMart API functions}
In this section we'll discuss functions that resemble other BioMart API's such as Martshell (see: http://www.biomart.org for more info).   These functions are very general and can be used on all BioMart databases.  The order in which the functions are discussed is the usual order of how you should use them.

\subsection{listMarts}

The \Rfunction{listMarts} lists the possible BioMarts where we can connect to.

<<>>=
library(biomaRt)
marts <- listMarts()
marts
@

\subsection{useMart}

Here we select from the list of possible BioMart databases, a BioMart that we want to use.  You have to specify the full name of the BioMart e.g. "ensembl\_mart\_32".
<<>>=
index<-grep("ensembl",marts)
mart <- useMart(marts[index])
@
\subsection{listDatasets}

Next we want to select a specific dataset of the selected BioMart. To see which dataset is available we use the function \Rfunction{listDatasets}.

<<>>=
listDatasets(mart)
@

\subsection{useDataset}

To actually use a dataset we use the function \Rfunction{useDataset} to update our Mart object so it contains the configuration information of the dataset of interest.

<<>>=

mart<-useDataset(dataset="hsapiens_gene_ensembl",mart=mart)

@

\subsection{Filter, Values and Attributes}

In BioMart, a filter is used to search a set of attributes that have a specified value for that filter.  To explain this better lets consider the following use case.  We want to get the gene symbol, chromosome name and band of the following features on the affy hgu95av2 chip: 1939\_at,2082\_s\_at and 1454\_at.  In this case the attributes are gene symbol, chromosome name and band, they are the information we want to retrieve.  The filter is the hgu95av2 chip and as values for this filter we use the affy identifiers we want to retrieve the information from.   
In BioMart a list of possible attributes that we can query for can be retrieved by using the function \Rfunction{listAttributes}

<<>>=

attributes <- listAttributes(mart) 
attributes[1:10]

@

Similarly a list of possible filters can be obtained with the function \Rfunction{listFilters}.

<<>>=
filters <- listFilters(mart)
filters[1:10]
@

To get the information from our example we can use the function \Rfunction{getBM}, using valid attributes and filter.

<<>>=

getBM(attributes="hgnc_symbol",filter="affy_hg_u95av2",values=c("1939_at","2082_s_at","1454_at","1000_at"), mart=mart)
getBM(attributes=c("chr_name","band"),filter="affy_hg_u95av2",values=c("1939_at","2082_s_at","1454_at", "1000_at"), mart=mart)
martDisconnect(mart)
@

As you see multiple attributes can be retrieved at once but in the current version of biomaRt there is the restriction that the attributes which are queried together, should somehow be of a similar type, e.g. chromosome band and chromosome name or e.g. allele, SNP, and frequency of snp.\\ 

\end{document}
