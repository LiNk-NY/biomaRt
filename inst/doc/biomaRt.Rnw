%\VignetteIndexEntry{biomaRt}
%\VignetteDepends{biomaRt}
%\VignetteKeywords{biomaRt}
%\VignettePackage{biomaRt}
%\documentclass[12pt, a4paper]{article}
\documentclass[12pt]{article}

\usepackage{amsmath,epsfig,psfig,pstricks,fullpage}
\usepackage{hyperref}
\usepackage{url}
\usepackage[authoryear,round]{natbib}

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}




\author{Steffen Durinck$^\ddagger$\footnote{Steffen.Durinck@esat.kuleuven.ac.be}, Wolfgang Huber$^\P$\footnote{huber@ebi.ac.uk},\\Yves Moreau$^\ddagger$, Bart De Moor$^\ddagger$}
\begin{document}
\title{Description of the biomaRt package}

\maketitle
\begin{center} $^\ddagger$Department of Electronical Engineering, ESAT-SCD, K.U.Leuven,\\ Kasteelpark Arenberg 10, 3001 Leuven-Heverlee, Belgium, \url{http://www.esat.kuleuven.ac.be/~dna/BioI}\\and $^\P$European Bioinformatics Institute, Hinxton, UK

 \end{center}

%library(tools)
%Rnwfile<- file.path("/home/steffen/programming/R/biomaRt/inst/doc/biomaRt.Rnw")
%Sweave(Rnwfile,pdf=TRUE,eps=TRUE,stylepath=TRUE,driver=RweaveLatex())

\tableofcontents
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
The BioConductor \Rpackage{biomaRt} package enables to directly query databases based on biomaRt such as Ensembl, a software system which produces and maintains automatic annotation on metazoan genomes.  This way you can annotate the features on your array with the latest annotations starting from identifiers such as affy id's, locuslink, RefSeq and more. Annotation includes gene names, GO and OMIM annotation (depending on species).\\
\section{objects}

\subsection{Mart-class}

An object of the \Robject{Mart} class stores connections to BioMart databases and aditional information about the BioMarts. It has the following slots:
\begin{itemize}
\item \Robject{connections}: stores the RMySQLConnections
\item \Robject{arrayToSpecies}: Stores mapping from affy arrays to species
\end{itemize}


\subsection{martTable-class}
 
An object of the \Robject{martTable} class is the output of most biomaRt funtions and has the following slots:
\begin{itemize}
\item \Robject{id}: stores the id used for querying
\item \Robject{table}: is a list of vectors storing the retrieved data
\end{itemize}

\section{Connecting to BioMart databases}

A first step in using the biomaRt package is to connect to a BioMart database. The function martConnect establishes a connection with one or more of the following BioMart databases: snp, ensembl, sequence and vega.  Default this function will connect to public BioMart databases.  If no biomart is specified, only a connection to ensembl will be established.  If you want to use local BioMart install you have to set the local argument to TRUE and specify host, password and user details in the corresponding arguments.   

\subsection{\Rfunction{martConnect}}

<<>>=
## load up the library
library(biomaRt)

#Connect to BioMart databases, using default (ensembl)
mart <- martConnect()
 
@

\subsection{\Rfunction{martDisconnect}}

You can only hold a limited number of connections with different BioMarts.  The function martDisconnect can be used to close a mart connection.

<<>>=

#Disconnect from BioMart databases

martDisconnect(mart)
 
@

\section{Annotating identifiers with gene information}

The function \Rfunction{getGene} uses a query id to look up the name, description and chromosomal information of the corresponding gene.
Currently the \Rfunction{getGene} function takes identifiers from entrezgene, ensembl, refseq, affy, hugo and embl.  Besides the id argument, this function also has a species, array and type argument.\\
The {\it id} argument is either a vector of identifiers or a single identifier to be annotated.\\
 The {\it species} argument should have the species from which the identifier originates.\\
The {\it array} argument takes affy array identifiers as values.  A list of possible identifiers supported by the package can be obtained by executing the function \Rfunction{getAffyArrays}.\\
The {\it mart} argument is a mart connection, which was obtained using the method \Rfunction{martConnect}.\\
The {\it type} takes the values of 'entrezgene','refseq','hugo', 'ensembl' and 'embl' to clarify which type of identifier is specified in the id argument.\\

First we connect to the BioMart databases we need (note that this should happen only once per session).  

<<>>=

mart <- martConnect(biomarts = c("ensembl", "snp","sequence")) 

@

Then we check which affy arrays are available:

<<>>=


getAffyArrays(mart)

@

Assume now that we have some upregulated features that we want to annotate. To get the gene information on a certain affy array do:

<<>>=

upregulated <- c("210708_x_at","202763_at","211464_x_at")

gene <- getGene( id = upregulated, array = "hgu133plus2", mart = mart)

gene
@

When using other id's we have to specify the \texttt{type} and \texttt{species}, use the function \Rfunction{getSpecies} to find valid species names.

<<>>=
getGene(id=100,species="hsapiens",type="entrezgene",mart=mart)

@


\section{GO annotation}

Gene Onotology annotation can be retrieved with the function \Rfunction{getGO}.  The arguments are the same as the function \Rfunction{getGene}.

<<>>=
go <- getGO( id = upregulated[1], array = "hgu133plus2", mart = mart)
go
@

\section{OMIM annotation}

OMIM annotation can be retrieved with the function \Rfunction{getOMIM}.  The arguments are the same as the function \Rfunction{getGene}.

<<>>=
omim <- getOMIM( id = "203140_at" , array = "hgu133plus2", mart = mart)
omim
@

\section{INTERPRO protein domains}

INTERPRO protein domains of the corresponding proteins can be searched with the function \Rfunction{getINTERPRO}. Again the arguments are the same as the function \Rfunction{getGene}.  

<<>>=

getINTERPRO(id="1939_at",array="hgu95av2",mart=mart)

@


\section{Homology mapping}

This function maps homologs of genes of one species to another species.
To see which species are available do:\\

<<>>=
getSpecies(mart)

@

Now we can look for homologs:

<<>>=

getHomolog(id = 2,from.species = 'hsapiens', to.species = 'mmusculus', from.type = 'entrezgene', to.type = 'refseq',mart = mart)

getHomolog(id = "1939_at",to.array = "canine", from.array = "hgu95av2",mart = mart )

@


\section{Identify subsets of genes for further analysis with the \Rfunction{getFeature} function}

The function \Rfunction{getFeature} is a general function to look up identifiers which pass a certain filter.  A first such a filter is to look for identifiers that correspond to genes with a given symbol.  If the array argument is given then affy identifiers from that array will be returned.  For retrieving other identifiers one has to specify the species and the type of identifier to retrieve.\\

<<>>=
getFeature(symbol="BRCA2",array="hgu95av2",mart=mart)
@

A second possible filter is to look for id's which have a certain OMIM disease term attached to them (this only works for hsapiens).

<<>>=
getFeature(OMIM="diabetes mellitus", type="refseq", species="hsapiens",mart=mart)
@

Similarly one can look for id's that have a certain GO annotation e.g. retrieve all affy id's on the hgu133plus2 array which have protein-tyrosine kinase activity.\\

<<>>=

tyrkinase <- getFeature(GO="protein-tyrosine kinase",array="hgu133plus2",mart=mart)

@

An other filter uses the position of genes on the genome.  One can query for all genes on a certain chromosome:

<<>>=
ychrom <- getFeature(chromosome="Y",type="entrezgene",species="hsapiens",mart=mart)
ychrom@id[1:10]

@

Or query for genes that lay in a particular region:\\

<<>>=
getFeature(chromosome=21,start=30000000, end = 35000000, array="hgu95av2",mart=mart)
@

\section{Sequence information}

The function \Rfunction{getSequence} retrieves the sequence given it's chromosome, start and end position.

<<>>=

getSequence(species="ggallus", chromosome = 1, start = 400, end = 500, mart = mart)

@


\section{Single Nucleotide Polymorphisms}

The function \Rfunction{getSNP} retrieves all SNP's between a given a start and end position on a gives chromosome..
Note:  make sure you have a Mart object with connections to ensembl and snp

<<>>=

getSNP(chromosome = 8, start = 148350, end = 148612, species ="hsapiens", mart = mart)

@

\section{More exotic functions}
\subsection{\Rfunction{getPossibleXrefs}}

This function retrieves the possible cross-references present in Ensembl.  This is a very general function to see what can be extracted from En
sembl.  The results of this function can be used in the getXref function to extract the data of interest.

<<>>=
xref <- getPossibleXrefs(mart = mart)
xref[1:10,]

@


\subsection{\Rfunction{getXref}}

This powerful function retrieves any cross reference in Ensembl.  It can for example be used to map different affymetrix array within one species.
E.g. starting from an affy id of chip hgu95av2 and id 1939\_at, look for corresponding affy identifiers on the affy hgu133plus2 chip.

<<>>=

getXref(id=c("1939_at"), from.species="hsapiens", to.species = "hsapiens", from.xref ="affy_hg_u95av2", to.xref="affy_hg_u133_plus_2",mart=mart)

@


\end{document}
