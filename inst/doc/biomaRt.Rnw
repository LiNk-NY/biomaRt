%\VignetteIndexEntry{The biomaRt users guide}
%\VignetteDepends{biomaRt}
%\VignetteKeywords{Annotation}
%\VignettePackage{biomaRt}
\documentclass[11pt]{article}
\usepackage{hyperref}
\usepackage{url}
\usepackage[authoryear,round]{natbib}
\bibliographystyle{plainnat}

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}

\author{Steffen Durinck\footnote{steffen@stat.berkeley.edu}}
\begin{document}
\title{The biomaRt users guide}

\maketitle

\tableofcontents
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

In recent years a wealth of biological data has become available in public data repositories. Easy access to these valuable data resources and firm integration with data analysis is needed for comprehensive bioinformatics data analysis.  The \Rpackage{biomaRt} package,  provides an interface to a growing collection of databases implementing the BioMart software suite (\url{http://www.biomart.org}). The package enables retrieval of large amounts of data in a uniform way without the need to know the underlying database schemas or write complex SQL queries. Examples of BioMart databases are Ensembl, Uniprot and HapMap. These major databases give biomaRt users direct access to a diverse set of data and enable a wide range of powerful online queries from R.

\section{Selecting a BioMart database and dataset}

Every analysis with \Rpackage{biomaRt} starts with selecting a BioMart database to use.  A first step is to check which BioMart web services are available.  The function \Rfunction{listMarts} will display all available BioMart web services   

<<echo=FALSE>>=
library(annotate)
options(width=120)
@

\begin{small}
<<>>=
library(biomaRt)
listMarts()
@
\end{small}

Note: if the function \Rfunction{useMart} runs into proxy problems you should set your proxy first before calling any biomaRt functions.  
You can do this using the Sys.putenv command:

\begin{verbatim}
Sys.putenv("http\_proxy" = "http://my.proxy.org:9999")
\end{verbatim}

The \Rfunction{useMart} function can now be used to connect to a specified BioMart database, this must be a valid name given by \Rfunction{listMarts}. In the next example we choose to query the Ensembl BioMart database.

<<>>=
ensembl=useMart("ensembl")
@

BioMart databases can contain several datasets, for Ensembl every species is a different dataset.  In a next step we look at which datasets are available in the selected BioMart by using the function \Rfunction{listDatasets}.

\begin{small}
<<>>=
listDatasets(ensembl)
@
\end{small}

To select a dataset we can update the \Robject{Mart} object using the function \Rfunction{useDataset}.  In the example below we choose to use the hsapiens dataset.

\begin{verbatim}
ensembl = useDataset("hsapiens_gene_ensembl",mart=ensembl)
\end{verbatim}

Or alternatively if the dataset one wants to use is known in advance, we can select a BioMart database and dataset in one step by:

<<>>=
ensembl = useMart("ensembl",dataset="hsapiens_gene_ensembl")
@

\section{How to build a biomaRt query}

The \Rfunction{getBM} function has three arguments that need to be introduced: filters, attributes and values.
\textit{Filters} define a restriction on the query.  For example you want to restrict the output to all genes located on the human X chromosome then the filter \textit{chromosome\_name} can be used with value 'X'. The \Rfunction{listFilters} function shows you all available filters in the selected dataset.\\

<<>>=
filters = listFilters(ensembl)
filters[1:5,]
@ 

\textit{Attributes} define the values we are interested in to retrieve.  For example we want to retrieve the gene symbols or chromosomal coordinates.  The listAttributes function displays all available attributes in the selected dataset.\\

<<>>=
attributes = listAttributes(ensembl)
attributes[1:5,]
@

The \Rfunction{getBM} function is the main query function in biomaRt.  It has four main arguments:\\
\begin{itemize}
\item attributes:  is a vector of attributes that one wants to retrieve (= the output of the query).
\item filters:  is a vector of filters that one wil use as input to the query.
\item values: a vector of values for the filters.  In case multple filters are in use, the values argument requires a list of values where each position in the list corresponds to the position of the filters in the filters argument (see examples below).
\item mart: is and object of class \Robject{Mart}, which is created by the \Rfunction{useMart} function.
\end{itemize}

Note: for some frequently used queries to Ensembl a set of wrapper are functions available as will be described in the sections below.  These wrapper functions are: \Rfunction{getGene}, \Rfunction{getSequence}, \Rfunction{getGO}, \Rfunction{getHomolog}, \Rfunction{getSNP}.  All these functions call the \Rfunction{getBM} function with hard coded filter and attribute names.\\

Now that we selected a BioMart database and dataset, and know about attributes, filters, and the values for filters; we can build a biomaRt query.  Let's make an easy query for the following problem:  We have a list of Affymetrix identifiers from the u133plus2 platform and we want to retrieve the corresponding EntrezGene identifiers using the Ensembl mappings.\\
The u133plus2 platform will be the filter for this query and as values for this filter we use our list of Affymetrix identifiers.  As output for the query we are interested in EntrezGene identifiers to the attributes that we want to retrieve will be EntrezGene and u133plus2 so we get a mapping of these two identifiers as a result.  The exact names that we will have to use to specify the attributes and filters can be retrieved with the listAttributes and listFilters function respectively.  Let's now run the query:\\

<<>>=
affyids=c("202763_at","209310_s_at","207500_at")
getBM(attributes=c('affy_hg_u133_plus_2', 'entrezgene'), filters = 'affy_hg_u133_plus_2', values = affyids, mart = ensembl)
@  
 
\section{Examples of biomaRt queries}

In the sections below a variety of example queries are described.  Every example is written as a task, and we have to come up with a biomaRt solution to the problem.

\subsection{Task 1:  Annotate a set of Affymetrix identifiers with HUGO symbol and chromosomal locations of corresponding genes}

\begin{scriptsize}
<<>>=
affyids=c("202763_at","209310_s_at","207500_at")
getBM(attributes=c('affy_hg_u133_plus_2', 'hgnc_symbol', 'chromosome_name','start_position','end_position', 'band'), filters = 'affy_hg_u133_plus_2', values = affyids, mart = ensembl)
@ 
\end{scriptsize}

As this is a frequently used query to Ensembl, a wrapper function getGene is provided that retrieves a standard set of information based for a given list of identifiers:

\begin{scriptsize}
<<>>=
getGene(id=affyids, type="affy_hg_u133_plus_2",mart=ensembl)
@
\end{scriptsize}

\subsection{Task 2:  Annotate a set of EntrezGene identifiers with GO annotation}


<<>>=
entrez=c("673","7157","837")
getBM(attributes=c('entrezgene','go','go_description','evidence_code'), filters='entrezgene', values=entrez, mart=ensembl)
@ 

As this is a frequently used query to Ensembl, a wrapper function getGO is provided that retrieves a standard set of information based for a given list of identifiers:

\begin{scriptsize}
\begin{verbatim}

> go = getGO(id="202763_at", type="affy_hg_u133_plus_2",mart=ensembl)
> go
  affy_hg_u133_plus_2         go                         go_description evidence_code ensembl_gene_id
1           202763_at GO:0005515                        protein binding           IPI ENSG00000164305
2           202763_at GO:0006508                            proteolysis           IDA ENSG00000164305
3           202763_at GO:0006915                              apoptosis           IEA ENSG00000164305
4           202763_at GO:0006917                 induction of apoptosis           TAS ENSG00000164305
5           202763_at GO:0008234       cysteine-type peptidase activity           IEA ENSG00000164305
6           202763_at GO:0030264 nuclear fragmentation during apoptosis           IMP ENSG00000164305
7           202763_at GO:0030693                       caspase activity           TAS ENSG00000164305
\end{verbatim}
\end{scriptsize}

\subsection{TASK 3: Retrieve all HUGO gene symbols of genes that are located on chromosomes 1,2 or Y , and are associated with one the following GO terms: "GO:0051330","GO:0000080","GO:0000114","GO:0000082" (here we'll use more than one filter)}
The \Rfunction{getBM} function enables you to use more than one filter.  In this case  the filter argument should be a vector with the filter names.  The values should be a list, where the first element of the list corresponds to the first filter and the second list element to the second filter and so on.  The elements of this list are vectors containing the possible values for the corresponding filters.
\begin{small}
\begin{verbatim}
 go=c("GO:0051330","GO:0000080","GO:0000114","GO:0000082")
 chrom=c(1,2,"Y")
 getBM(attributes= "hgnc_symbol",
        filters=c("go","chromosome_name"),
        values=list(go,chrom), mart=ensembl)
\end{verbatim}
\end{small}
\begin{scriptsize}
\begin{verbatim}
  hgnc_symbol
1      PPP1CB
2       SPDYA
3       ACVR1
4        CUL3
5        RCC1
6        CDC7
7        RHOU
\end{verbatim}
\end{scriptsize}


\section{getSequence}

Sequences can be retrieved using the \Rfunction{getSequence} function either starting from chromosomal coordinates or identifiers.  The chromosome name can be specified using the \textit{chromosome} argument.  The \textit{start} and \textit{end} arguments are used to specify \textit{start} and \textit{end} positions on the chromosome. The type of sequence returned can be specified by the seqType argument which takes the following values: 'cdna';'peptide' for protein sequences;'3utr' for 3' UTR sequences,'5utr' for 5' UTR sequences; 'gene\_exon' for exon sequences only; 'transcript\_exon' for transcript specific exonic sequences only;'transcript\_exon\_intron' gives the full unspliced transcript, that is exons + introns;'gene\_exon\_intron' gives the exons + introns of a gene;'coding' gives the coding sequence only;'coding\_transcript\_flank' gives the flanking region of the transcript including the UTRs, this must be accompanied with a given value for the upstream or downstream attribute;'coding\_gene\_flank' gives the flanking region of the gene including the UTRs, this must be accompanied with a given value for the upstream or downstream attribute; 'transcript\_flank' gives the flanking region of the transcript exculding the UTRs, this must be accompanied with a given value for the upstream or downstream attribute; 'gene\_flank' gives the flanking region of the gene excluding the UTRs, this must be accompanied with a given value for the upstream or downstream attribute.
In MySQL mode the \Rfunction{getSequence} function is more limited and the sequence that is returned is the 5' to 3'+ strand of the genomic sequence, given a chromosome, as start and an end position.

First we retrieve the 5'UTR sequences of all genes on chromosome 3 between a given start and end position.  We also have to specify which type of identifier we want to retrieve together with the sequences, here we choose for entrezgene identifiers.
\begin{small}
\begin{verbatim}
> utr5 = getSequence(chromosome=3, start=185514033, end=185535839,
                      type="entrezgene",seqType="5utr", mart=ensembl)
> utr5
\end{verbatim}
\end{small}
\begin{scriptsize}
\begin{verbatim}
          V1               V2
  .....GAAGCGGTGGC ....   1981
\end{verbatim}
\end{scriptsize}

Next we retrieve the protein sequences given a list of entrezgene identifiers.  In  this case the type argument specifies which type of identifiers we are using.
To get an overview of other valid identifier types we refer to the \Rfunction{listFilters} function.

\begin{small}
\begin{verbatim}
> protein = getSequence(id=c(100, 5728),type="entrezgene",
                        seqType="peptide", mart=ensembl)
> protein
\end{verbatim}
\end{small}
\begin{scriptsize}
\begin{verbatim}
 peptide               entrezgene
 MAQTPAFDKPKVEL ...    100
 MTAIIKEIVSRNKRR ...   5728

\end{verbatim}
\end{scriptsize}

\section{exportFASTA}

The data.frames obtained by the getSequence function can be exported to FASTA files using the \Rfunction{exportFASTA} function.
One has to specify the data.frame to export and the filename using the file argument.

\section{getFeature}
The \Rfunction{getFeature} function enables us to select a set of features based on chromosomal coordinates or GO identifiers.
Select all Affymetrix identifiers on the hgu133plus2 chip for genes located on chromosome 16 between basepair 1100000 and 1250000.
\textit{getFeature} takes the \textit{type} argument to specify the type of identifiers that need to be retrieved.

\begin{small}
\begin{verbatim}
> features = getFeature( type = "affy_hg_u133_plus_2",
                         chromosome = "16", start = "1100000",
                         end = "1250000", mart=ensembl)
> features
\end{verbatim}
\end{small}
\begin{scriptsize}
\begin{verbatim}

  ensembl_transcript_id chromosome_name start_position end_position affy_hg_u133_plus_2
1        ENST00000358590              16        1143739      1211772           222960_at
2        ENST00000358590              16        1143739      1211772           205845_at
3        ENST00000356546              16        1143739      1211772           222960_at
4        ENST00000356546              16        1143739      1211772           205845_at
5        ENST00000234798              16        1211659      1215257         220339_s_at
6        ENST00000357113              16        1218338      1220215         207741_x_at
7        ENST00000357113              16        1218338      1220215         215382_x_at
8        ENST00000357113              16        1218338      1220215         210084_x_at
9        ENST00000357113              16        1218338      1220215         205683_x_at
10       ENST00000357113              16        1218338      1220215         207134_x_at
11       ENST00000357113              16        1218338      1220215         217023_x_at
12       ENST00000357113              16        1218338      1220215         216474_x_at
13       ENST00000339687              16        1218338      1220215         215382_x_at
14       ENST00000339687              16        1218338      1220215         217023_x_at
15       ENST00000339687              16        1218338      1220215         216474_x_at
16       ENST00000338844              16        1230679      1232556         207741_x_at
17       ENST00000338844              16        1230679      1232556         215382_x_at
18       ENST00000338844              16        1230679      1232556         210084_x_at
19       ENST00000338844              16        1230679      1232556         205683_x_at
20       ENST00000338844              16        1230679      1232556         207134_x_at
21       ENST00000338844              16        1230679      1232556         217023_x_at
22       ENST00000338844              16        1230679      1232556         216474_x_at
23       ENST00000382804              16        1230679      1232556         207741_x_at
24       ENST00000382804              16        1230679      1232556         215382_x_at
25       ENST00000382804              16        1230679      1232556         210084_x_at
26       ENST00000382804              16        1230679      1232556         205683_x_at
27       ENST00000382804              16        1230679      1232556         207134_x_at
28       ENST00000382804              16        1230679      1232556         217023_x_at
29       ENST00000382804              16        1230679      1232556         216474_x_at
30       ENST00000382797              16        1246274      1248610           214568_at
31       ENST00000211076              16        1246274      1248610           214568_at
\end{verbatim}
\end{scriptsize}

Select all entrezgene ids which have a "MAP kinase activity" GO term associated with it.

\begin{small}
<<>>=
features=getFeature(type="entrezgene", GOID="GO:0004707", mart=ensembl)
features
@
\end{small}

\subsection{getSNP}
To retrieve SNP data we first have to connect to the snp BioMart database of Ensembl.

\begin{small}
\begin{verbatim}
> snpmart = useMart("snp", dataset = "hsapiens_snp")
Checking attributes and filters ... ok
> snp=getSNP(chromosome = 8, start = 148350, end = 148612,  mart = snpmart)
> snp
\end{verbatim}
\end{small}
\begin{scriptsize}
\begin{verbatim}

        tscid  refsnp_id allele chrom_start chrom_strand
1  TSC1723456  rs3969741    C/A      148394            1
2  TSC1421398  rs4046274    C/A      148394            1
3  TSC1421399  rs4046275    A/G      148411            1
4                rs13291    C/T      148462            1
5  TSC1421400  rs4046276    C/T      148462            1
6              rs4483971    C/T      148462            1
7             rs17355217    C/T      148462            1
8             rs12019378    T/G      148471            1
9  TSC1421401  rs4046277    G/A      148499            1
10            rs11136408    G/A      148525            1
11 TSC1421402  rs4046278    G/A      148533            1
12            rs17419210    C/T      148533           -1
13            rs28735600    G/A      148533            1
14 TSC1737607  rs3965587    C/T      148535            1
15             rs4378731    G/A      148601            1
\end{verbatim}
\end{scriptsize}

\subsection{getHomolog}
BioMart takes advantage of the many species present in Ensembl to do homology mappings.  By using two datasets (i.e. two species), we can apply the \Rfunction{getHomolog} function to map identifiers from one species to the other.
Similar as the \Rfunction{getGene} function, we have to specify the identifier we start from using either the \textit{from.array} argument if the identifier comes from an affy array or else the \textit{from.type} argument if we use an other identifier.  The identifier we want to retrieve has to be specified by using the \textit{to.array} or \textit{to.type} arguments.\\
A generalized version of the \Rfunction{getHomolog} function is the \Rfunction{getLDS} function (see Advanced Queries section). \Rfunction{getLDS} enables one to combine two datasets (=species in Ensembl) and query any field from one dataset based on the other.

In a first example we start from a affy identifier of a human chip and we want to retrieve the identifiers of the corresponding homolog on a mouse chip. 
\begin{small}
\begin{verbatim}
> human = useMart("ensembl","hsapiens_gene_ensembl")
> mouse = useMart("ensembl","mmusculus_gene_ensembl")
> homolog = getHomolog( id = "1939_at", to.type = "affy_mouse430_2", from.type = 
                        "affy_hg_u95av2", from.mart = human, to.mart = mouse )

> homolog
       V1           V2
1 1939_at 1427739_a_at
2 1939_at 1426538_a_at

\end{verbatim}
\end{small}
An other example starts from a human RefSeq id and we want to retrieve the corresponding affy ids on the affy mouse430\_2 chip.

\begin{small}
\begin{verbatim}
> homolog = getHomolog( id = "NM_007294", to.type = "affy_mouse430_2",
                        from.type = "refseq_dna", from.mart = human,
                        to.mart = mouse )

> homolog
        V1           V2
1 NM_007294   1424629_at
2 NM_007294   1451417_at
3 NM_007294 1424630_a_at

\end{verbatim}
\end{small}

\section{Advanced data retrieval with BioMart}

The previous functions were all tailored to the Ensembl BioMart web service.  In this section we will see biomaRt functions that can be used to retrieve everything that is available by any BioMart.  Three terms have to be introduced first: filters, attributes and values.
A filter defines a restriction on the query.  For example you want to restrict the output to all genes located on the human X chromosome then the filter \textit{chromosome\_name} can be used with value 'X'.\\
Attributes define the values we are interested in to retrieve.  For example we want to retrieve the gene symbols or chromosomal coordinates.\\
We will first demonstrate the use of filters and attributes with Ensembl and use it with other BioMarts.

\subsection{listFilters and filterSummary}

In BioMart databases, filters can be grouped.
Ensembl for example contains the filter groups GENE:, REGION:, ...
An overview of the categories and groups for attributes present in the respective BioMart dataset can be obtained with the \Rfunction{filterSummary} function.

\begin{small}
<<>>=
summaryF = filterSummary(ensembl)
summaryF[1:5,]
@
\end{small}

To show us a smaller list of filters which belog to a specified group or category we can now specify this in the \Rfunction{listFilters} function as follows:

\begin{small}
<<>>=
listFilters(ensembl, group = "REGION:")
@
\end{small}

We now get a short list of filters related to the region where the genes are located.

\subsection{filterType}

Boolean filters need a value TRUE or FALSE in biomaRt.  Setting the value TRUE will include all information that fulfill the filter requirement.  Setting FALSE will exclude the information that fulfills the filter requirement and will return all values that don't fulfill the filter.
For most of the filters, their name indicates if the type is a boolean or not and they will usually start with "with".  However this is not a rule and to make sure you got the type right you can use the function \Rfunction{filterType} to investigate the type of the filter you want to use.

\begin{small}
<<>>=
filterType("with_affy_hg_u133_plus_2",ensembl)
@
\end{small}

\subsection{filterOptions}

Some filters have a limited set of values that can be given to them.  To know which values these are one can use the \Rfunction{filterOptions} function to retrieve the predetermed values of the respective filter.

\begin{small}
<<>>=
filterOptions("biotype",ensembl)
@

\end{small}

If there are no predetermed values e.g. for the entrezgene filter, then \Rfunction{filterOptions} will return the type of filter it is. And most of the times the filter name or it's description will suggest what values one case use for the respective filter (e.g. entrezgene filter will work with enterzgene identifiers as values)


\subsection{listAttributes and attributeSummary}

For large BioMart databases such as Ensembl, the number of attributes displayed by the \Rfunction{listAttributes} function can be very large. 
In BioMart databases, attributes are put together in categories, such as Sequences, Features, Homologs for Ensembl, and within these categories, attributes can be grouped.
The Features category of Ensembl for example contains the attribute groups GENE:, PROTEIN:, ...
An overview of the categories and groups for attributes present in the respective BioMart dataset can be obtained with the \Rfunction{attributeSummary} function.

\begin{small}
<<>>=
summaryA = attributeSummary(ensembl)
summaryA[1:10,]
@
\end{small}

To show us a smaller list of attributes which belog to a specified group or category we can now specify this in the \Rfunction{listAttributes} function as follows:

\begin{small}
<<>>=
listAttributes(ensembl, category  = "Features", group = "GENE:")
@
\end{small}

We now get a short list of attributes related to the region where the genes are located.

\subsection{Example queries getBM}

\subsubsection{Using a BioMart other than Ensembl}

To demonstrate the use of the biomaRt package with non-Ensembl databases the next query is performed using the Wormbase BioMart (WormMart).
We connect to Wormbase, select the gene dataset to use and have a look at the available attributes and filters.  Then we use a list of gene names as filter and retrieve associated RNAi identifiers together with a description of the RNAi phenotype.
<<echo=TRUE, eval=FALSE>>=
wormbase=useMart("wormbase",dataset="gene")
listFilters(wormbase)
listAttributes(wormbase)
getBM(attributes=c("name","rnai","rnai_phenotype","phenotype_desc"),
                     filters="gene_name", values=c("unc-26","his-33"),
                     mart=wormbase)
     
@
\begin{scriptsize}
\begin{verbatim}
     name  rnai               rnai_phenotype                                     phenotype_desc

1  his-33 WBRNAi00000104   Emb | Nmo         embryonic lethal | Nuclear morphology alteration in early embryo
2  his-33 WBRNAi00012233   WT                                             wild type morphology
3  his-33 WBRNAi00024356   Ste                                                          sterile
4  his-33 WBRNAi00025036   Emb                                                 embryonic lethal
5  his-33 WBRNAi00025128   Emb                                                 embryonic lethal
6  his-33 WBRNAi00025393   Emb                                                 embryonic lethal
7  his-33 WBRNAi00025515   Emb | Lva | Unc                 embryonic lethal | larval arrest | uncoordinated
8  his-33 WBRNAi00025632   Gro | Ste                                            slow growth | sterile
9  his-33 WBRNAi00025686   Gro | Ste                                            slow growth | sterile
10 his-33 WBRNAi00025785   Gro | Ste                                            slow growth | sterile
11 his-33 WBRNAi00026259   Emb | Gro | Unc                   embryonic lethal | slow growth | uncoordinated
12 his-33 WBRNAi00026375   Emb                                                 embryonic lethal
13 his-33 WBRNAi00026376   Emb                                                 embryonic lethal
14 his-33 WBRNAi00027053   Emb | Unc                                 embryonic lethal | uncoordinated
15 his-33 WBRNAi00030041   WT                                             wild type morphology
16 his-33 WBRNAi00031078   Emb                                                 embryonic lethal
17 his-33 WBRNAi00032317   Emb                                                 embryonic lethal
18 his-33 WBRNAi00032894   Emb                                                 embryonic lethal
19 his-33 WBRNAi00033648   Emb                                                 embryonic lethal
20 his-33 WBRNAi00035430   Emb                                                 embryonic lethal
21 his-33 WBRNAi00035860   Egl | Emb                             egg laying defect | embryonic lethal
22 his-33 WBRNAi00048335   Emb | Sister Chromatid Separation abnormal (Cross-eyed)   embryonic lethal |
23 his-33 WBRNAi00049266   Emb | Sister Chromatid Separation abnormal (Cross-eyed)     embryonic lethal |
24 his-33 WBRNAi00053026   Emb | Sister Chromatid Separation abnormal (Cross-eyed)     embryonic lethal |
25 unc-26 WBRNAi00021278   WT                                             wild type morphology
26 unc-26 WBRNAi00026915   WT                                             wild type morphology
27 unc-26 WBRNAi00026916   WT                                             wild type morphology
28 unc-26 WBRNAi00027544   Unc                                                    uncoordinated
29 unc-26 WBRNAi00049565   WT                                             wild type morphology
30 unc-26 WBRNAi00049566   WT                                             wild type morphology
\end{verbatim}
\end{scriptsize}

\subsection{getLDS and linking BioMart datasets}

The \Rfunction{getLDS} (Get Linked Dataset) function provides functionality to link 2 BioMart datasets which each other and construct a query over the two datasets.
The usage of getLDS is very similar to \Rfunction{getBM}.  The linked dataset is provided by a separate Mart object and one has to specify filters and attributes for the linked dataset.  Note that this function only works in web service mode.  Filters can either be applied to both datasets or to one of the datasets. When used with Ensembl, \Rfunction{getLDS} is a generalized version of the \Rfunction{getHomolog} function.
Below is an example on how to use \Rfunction{getLDS}.

\begin{scriptsize}
\begin{verbatim}
human = useMart("ensembl", dataset = "hsapiens_gene_ensembl")
mouse = useMart("ensembl", dataset = "mmusculus_gene_ensembl")
getLDS(attributes = c("hgnc_symbol","chromosome_name", "start_position"),
       filters = "hgnc_symbol", values = "TP53",mart = human,
      attributesL = c("chromosome_name","start_position"), martL = mouse)

   V1 V2      V3 V4       V5
1 TP53 17 7512464 11 69396600
2 TP53 17 7512464 11 69396600
\end{verbatim}
\end{scriptsize}

\section{Local BioMart databases}

The biomaRt package can be used with a local install of a public BioMart database or a locally developed BioMart database.
In order for biomaRt to recognize the database as a BioMart, make sure that the local database you create has a name conform with \begin{verbatim} database_mart_version \end{verbatim} where database is the name of the database and version is a version number.  No more underscores than the ones showed should be present in this name. A possible name is for example \begin{verbatim} ensemblLocal\_mart\_42 \end{verbatim}.
\subsection{Minimum requirements for local database installation}
One needs to first download the SQL code to generate the database.  For ensembl\_mart\_42 this was in the file ensembl\_mart\_42.sql.gz. 
Then run this SQL code to generate the tables of your local database:

\begin{verbatim}
mysql -D ensembl_mart_42 -u username -p < ensembl_mart_42.sql
\end{verbatim}

Once the tables are created you need to fill the following tables with the downloaded data:
\begin{scriptsize}
\begin{verbatim}
Essential tables:

meta_conf__dataset__main.txt.table
meta_conf__xml__dm.txt.table

You can install them from your MySQL command line with:

LOAD DATA INFILE 'meta_conf__dataset__main.txt.table' INTO TABLE meta_conf__dataset__main;
LOAD DATA INFILE 'meta_conf__xml__dm.txt.table' INTO TABLE meta_conf__xml__dm;
\end{verbatim}
\end{scriptsize}

Next you load all the tables that have the name of your species of interest with with the corresponding table data.
Once the local database is installed you can use biomaRt on this database by:
\begin{scriptsize}
\begin{verbatim}
mart=useMart("ensembl_mart_42", mysql=TRUE, host="localhost", user="****", password="****", 
              local=TRUE, dataset="hsapiens_gene_ensembl")
\end{verbatim}
\end{scriptsize}

For more information on how to install a public BioMart database see:  http://www.biomart.org/install.html and follow link databases.
\section{Session Info}
<<>>=
sessionInfo()
warnings()
@
\end{document}
